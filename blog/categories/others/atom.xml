<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Others | Actionary]]></title>
  <link href="http://blog.zhangliaoyuan.com/blog/categories/others/atom.xml" rel="self"/>
  <link href="http://blog.zhangliaoyuan.com/"/>
  <updated>2015-08-31T13:53:26+08:00</updated>
  <id>http://blog.zhangliaoyuan.com/</id>
  <author>
    <name><![CDATA[Eric Zhang]]></name>
    <email><![CDATA[zhang.lyuan@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Ways to Break the Dependency During Unit Testing in C/C++ Programming]]></title>
    <link href="http://blog.zhangliaoyuan.com/blog/2015/05/15/thy-ways-to-break-the-dependency-during-unit-testing-in-c_c++-programming/"/>
    <updated>2015-05-15T23:01:06+08:00</updated>
    <id>http://blog.zhangliaoyuan.com/blog/2015/05/15/thy-ways-to-break-the-dependency-during-unit-testing-in-c_c++-programming</id>
    <content type="html"><![CDATA[<p>We encourage people writes unit testing shall follow <a href="http://agileinaflash.blogspot.de/2009/02/first.html" title="Fast, Isolated, Repeatable, Self-Validating and Timely">F.I.R.S.T principle</a>, but dependency gets in the way. Especially you make unit testing under legacy code, that&rsquo;s mess. That&rsquo;s the excuse we plan to ignore unit testing during coding.</p>

<p>For example, there is SUT code is <code>game.c</code>:</p>

<pre><code class="c++">bool is_win() {
    printf("is_win is invoked!\n");
    if (dice_points() &gt; 3) {
        return true;
    }
    return false;
}
</code></pre>

<p>function <code>is_win()</code> relies on the return value of function <code>dice_points()</code> which is defined in another file called <code>dice.c</code>:</p>

<pre><code class="c++">int dice_points() {
    printf("dice_points is invoked!\n");
    return rand() % 6 + 1;
}
</code></pre>

<p>If we would like to test <code>is_win()</code>, see the test case like this:</p>

<pre><code class="c++">TEST(VerifyGame, test_the_game_is_win) {
    CHECK(is_win());
}
</code></pre>

<p>The problem is you don&rsquo;t know the case will be pass or not, since the dependent function <code>dice_points()</code> return value is volatile, this test case is unrepeatable. So we need define a test double called <code>stub_dice_points()</code> to replace real implementation of <code>dice_points()</code>, and return a value which is configurable, like this:</p>

<pre><code class="c++">static int m_points = 0;

void set_stub_dice_points(int point){
    m_points = point;
}

int stub_dice_points() {
    return m_points;
}
</code></pre>

<p> And during you execute <code>is_win()</code> function, use <code>stub_dice_points()</code> instead of <code>dice_points()</code>, when you implement the unit testing like this:
<code>c++
 TEST (VerifyGame, test_bigger_than_three_points_shall_be_win) {
     set_stub_dice_points(3 + 2);
     CHECK(is_win());
}
</code>
But problem is how to replace the <code>dice_points()</code> with <code>stub_dice_points()</code>? There are some ways here:</p>

<h2>1. Pre-compile macro</h2>

<p>Macro <code>#ifdef</code>,  <code>#else</code> and <code>#endif</code> can be used during pre-compile phase, to select which source code statement can be compiled. So the SUT source code <code>game.c</code> can be modified like this:</p>

<pre><code class="c++">bool is_win() {
    printf("is_win is invoked!\n");
#ifndef UNIT_TEST
    if (dice_points() &gt; 3) {
#else
    if (stub_dice_points() &gt; 3) {
#endif
        return true;
    }
    return false;
}
</code></pre>

<p>And during compile the source code for unit testing purpose, give the <code>-DUNIT_TEST</code> compilation option, to enable the replacement. But this way requires you modify productive source code, and there will be a lot of macro like this, too ugly, and the source code readability will be getting worse.</p>

<h2>2. Function pointer replacement</h2>

<p>Another way is define a function pointer, in production code, the pointer is points a real depended function, and during unit testing, the function pointer will point the stub function, but it requires programmer change the production code like thisï¼Œ for example, the <code>dice.h</code> change like this:</p>

<pre><code class="c++">external int (*dice_pionts)();
</code></pre>

<p>and the <code>dice.c</code> change to this:</p>

<pre><code class="c++">int dice_points_imp() {
    printf("dice_points is invoked!\n");
    return rand() % 6 + 1;
}

int (*dice_pionts)() = dice_points_imp;
</code></pre>

<p>After that, in the test case, you can use the function pointer re-assignment like below (in cpputest framework):</p>

<pre><code class="c++">TEST(VerifyGame, test_the_dice_points_is_bigger_than_3_points_shall_be_win) {
    UT_PTR_SET(dice_points, stub_dice_points);
    set_stub_dice_points(3 + 2)
    CHECK(is_win());
}
</code></pre>

<p>The obvious disadvantage is production code changing is needed. You can image that, every function dependency shall be replaced by function pointer way, too ugly.</p>

<h2>3. Linker links replaced object</h2>

<p>Above two ways require to change the production code, is there any can avoid the production code change to complete the function replacement.
We assume the <code>game.c</code> includes <code>dice.h</code>, and <code>dice.c</code> is to implement the function <code>dice_ponits()</code> implementation. If we define another <code>stub.c</code> to implement the function <code>dice_points()</code> implementation in stub way. During compile the unit testing binary, don&rsquo;t compile the <code>dice.c</code>, just compile <code>game.c</code> and <code>stub.c</code>, and link them together to build a executable binary file.</p>

<p>But there will be another problem occurs: How many <code>*.c</code> files under testing, there will be how many unit testing executable binary files. But, if the function <code>is_win()</code> and <code>dice_points()</code> in the same file, how to replace it? It will be difficult.</p>

<h2>4. Dynamically replace</h2>

<p>Is there any way to replace the dependency without do any production code change? The answer is yes, here we would like to introduce a tricky way to replace the dependency: During the function invoking, we let the invoking jump to our defined stub function.
For example, during <code>isWin()</code> invoke <code>dice_points()</code>, we change the memory stack information, leads the invoking to jump to <code>stub_dice_points()</code>. The principle is first make the code page where <code>dice_points()</code> located writable using <code>mprotect()</code> in Linux or <code>VirtualProect()</code> in Win32. Then overwrite a <code>JMP</code> instructor which jump to <code>stub_dice_poinots()</code> at the begin of <code>dice_points()</code> binary code.</p>

<p>For example, there is a assistant source code <code>assistant.c</code> which includes <code>set_stup()</code> and <code>reset_stub()</code> implementation. The two are used to the dependency replacement:</p>

<pre><code class="c++">//assistant.h
#ifndef __ASSISTANT_H__
#define __ASSISTANT_H__

#ifdef __cplusplus
extern "C" {
#endif

#define JUMP_CODE_MAX   0x05
#define JUMP_CODE_CMD   0xE9
#define JUMP_CODE_RET   0xC3

typedef struct stubInfo {
  void *funcAddr;
  unsigned char byteCode[5];
} stubInfo;

extern void set_stub(void *funcAddr, void *stubAddr, stubInfo *si);
extern void reset_stub(stubInfo *si);
#ifdef __cplusplus
}
#endif
#endif /* __ASSISTANT_H__ */
</code></pre>

<p>And the <code>assistant.c</code> is here:</p>

<pre><code class="c++">#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;
#include "assistant.h"

static void set_jump_code(void *codeAddr, char jumpCode[JUMP_CODE_MAX]) {
  int pagesize = sysconf(_SC_PAGE_SIZE);
  if (mprotect((void*) ((unsigned long) codeAddr &amp; (~(pagesize - 1))), pagesize, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) {
    return;
  }
  memcpy(codeAddr, jumpCode, JUMP_CODE_MAX);
}

void set_stub(void *funcAddr, void *stubAddr, stubInfo *si) {
    char jumpCode[JUMP_CODE_MAX] = {JUMP_CODE_CMD};
    int  dist = stubAddr - funcAddr - 5;

    memcpy((void *)&amp;jumpCode[1], (void *)&amp;dist, sizeof(void *));
    si-&gt;funcAddr = funcAddr;
    memcpy((void *)&amp;si-&gt;byteCode[0], (void *)funcAddr, JUMP_CODE_MAX);

    set_jump_code(funcAddr, jumpCode);
}

void reset_stub(stubInfo *si)
{
    char   jumpCode[JUMP_CODE_MAX];
    memcpy((void *)&amp;jumpCode, (void *)&amp;si-&gt;byteCode[0], JUMP_CODE_MAX);
    set_jump_code(si-&gt;funcAddr, jumpCode);
}
</code></pre>

<p>And then in the unit test file, you can use the assistant function for the dependency replacement:
<code>
TEST(VerifyGame, test_the_dice_points_is_bigger_than_3_points_shall_be_win) {
    stubInfo si;
    set_stup(dice_points, stub_dice_points, &amp;si);
    set_stub_dice_points(3 + 2);
    CHECK(is_win());
    reset_stub(&amp;si);
}
</code></p>

<h2>5. Inherit from abstract class, replaced in dependency injection way</h2>

<p>As we know, in OOP, there is interface concept, in C++, there is abstract class which used for interface purpose. If above the functions are defined as class way, there will be like this:</p>

<pre><code class="c++">//game.h
class Game {
public:
    bool isWin() {
        Dice dice;
        if (dice.points() &gt; 3) {
            return true;
        }
        return false;
    }
};
</code></pre>

<p>and the <code>dice</code> class is like this:
<code>
class Dice{
public:
    int points(){
        return rand() % 6 + 1;
    }
};
</code>
If we would like to make the replacement, we have to define an abstract class called <code>Player</code> like this:</p>

<pre><code class="c++">class Player{
public:
    int points() = 0;
};
</code></pre>

<p>And the class <code>Dice</code> inherits from <code>Player</code> like this:</p>

<pre><code class="c++">class Dice: public Player {
public:
    int points() {
        return rand() % 6 + 1;
    }
};
</code></pre>

<p>And the <code>Game</code> class shall make some change as well:</p>

<pre><code class="c++">class Game {
private:
    Player m_opponent;
public:
    Game(Player player) {
        m_opponent = player;
    }

    bool isWin(){
        if (m_opponent.points() &gt; 3){
            return true;
        }   
        return false;
    }
};
</code></pre>

<p>The constructor function is used to <a href="http://martinfowler.com/articles/injection.html" title="Inject">dependency injection</a>. In test purpose, we will inherit a new class called <code>StubDice</code> from abstract class <code>Player</code>, and use the <code>StubDice</code> replace the real <code>Dice</code> in test case:</p>

<pre><code class="c++">//stub_dice.h
class StubDice: public Player {
private:
    int m_points = 0;
public:
    void set_points(int points) {
        m_points = points;
    }
    int points() {
        return m_points;
    }
}
</code></pre>

<p>In the test case, the implementation as below:</p>

<pre><code class="c++">TEST(VerifyGame, test_the_dice_points_less_3_points_shall_be_lose) {
    StubDice stub;
    Game *game = new Game(stub);
    stub.set_points( 3 - 1);
    CHECK(!game-&gt;isWin());
}
</code></pre>

<h2>Summary</h2>

<p>We list the 5 ways of dependency breaking, it doesn&rsquo;t mean that we suggest you use the ways in unit testing. During unit testing, if we find that it&rsquo;s hard to make unit testing, we have to look back, check why it&rsquo;s too hard to implement unit testing. Is it the design problem? Is it too many dependency, why? Is there any other way to implement same requirements? Refactor your source code often, make it better.</p>

<p>Treat the unit testing as design tool, helps you make better design; treat unit testing as safety tools, facilitates you make source code change.</p>

<p>-EOF-</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Domain Name of This Site Will Be Changed Soon]]></title>
    <link href="http://blog.zhangliaoyuan.com/blog/2015/04/02/use-new-domain-name/"/>
    <updated>2015-04-02T22:01:06+08:00</updated>
    <id>http://blog.zhangliaoyuan.com/blog/2015/04/02/use-new-domain-name</id>
    <content type="html"><![CDATA[<p>Hi, my dear friends,</p>

<p>I setup zhangliaoyuan.me for two years, now the domain name will be expired soon.
But good news is, I have got new domain name with my full name dot com, so after previous zhangliaoyuan.me domain name be expired in 2015/04/19, I&rsquo;ll use new domain name <strong><a href="http://blog.zhangliaoyuan.com" title="Eric's personal web site">blog.zhangliaoyuan.com</a></strong>, I&rsquo;m looking forward to your further supporting. A bundle of thanks for all of you, keep in touch.</p>

<p>./Eric</p>

<p>-EOF-</p>
]]></content>
  </entry>
  
</feed>
